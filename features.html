---
layout: static
---

<h1>Features</h1>

<p class="header__paragraph">
    atoum is a full-featured testing framework. Judge for yourself.
</p>

<section class="visual-section">
    <h2>Flexible structure</h2>

    <p>Test suites, test cases, directory names… feel free to rename everything
        to fit your particular needs.</p>
</section>

<section class="visual-section">
    <h2>Execution engines</h2>

    <p>By default, atoum provides three execution engines:</p>
    <ul class="bare block-list">
        <li style="max-width: 25%">
            <figure>
                <svg viewBox="0 0 100 100" style="max-width: 100px">
                    <rect x="0" y="0" width="100" height="100" stroke="#000" fill="none" />
                </svg>
            </figure>
            <strong>Inline</strong>, one test case after another in the same
            process,
        </li>
        <li style="max-width: 25%">
            <figure>
                <svg viewBox="0 0 100 100" style="max-width: 100px">
                    <rect x="0" y="0" width="100" height="100" stroke="#000" fill="none" />
                </svg>
            </figure>
            <strong>Isolate</strong>, one test case after another but each time in a
            new process,
        </li>
        <li style="max-width: 25%">
            <figure>
                <svg viewBox="0 0 100 100" style="max-width: 100px">
                    <rect x="0" y="0" width="100" height="100" stroke="#000" fill="none" />
                </svg>
            </figure>
            <strong>Concurrent</strong>, “all” test cases at the same time in
            separated processes.
        </li>
    </ul>
    <p>A specific engine can be defined per test case in addition to a default
        one with the <code>@engine</code> annotation.</p>
    <p>Using the concurrent engine will provide a faster feedback, this will
        accelerate your development.</p>
</section>

<section class="visual-section">
    <h2>Vocabulary</h2>

    <p>Depending of the kind of tests we are making, there is several ways to
        write a test case. The “classic” (old) way is procedural:</p>
    <pre class="language-php"><code>$x      = 1;
$y      = 2;
$result = $x + $y;

$this->assertTrue($result === 3);</code></pre>

    <p>The “smarter” way by really using atoum's asserters:</p>
    <pre class="language-php"><code>$x      = 1;
$y      = 2;
$result = $x + $y;

$this->integer($result)->isEqualTo(3);</code></pre>

    <p>The “academic” way:</p>
    <pre class="language-php"><code>$this
    ->given(
        $x = 1,
        $y = 2
    )
    ->when($result = $x + $y)
    ->then
        ->integer($result)
            ->isEqualTo(3);</code></pre>

    <p>In the later example, the <code>given</code>, <code>when</code> and
        <code>then</code> keywords are “empty asserters”. They execute nothing.
        They are used to provide a better test case design.</p>

</section>

<section class="visual-section">
    <h2>Meaningful asserters</h2>

    <p>atoum provides a
        <a href="http://docs.atoum.org/en/latest/chapter2.html#asserters">full-featured
            set of natural and expressive assertions</a> making test cases as much readable
        as possible. The following example asserts the integer <code>150</code> is
        greater than <code>100</code> and lower than or equal to
        <code>200</code>:</p>

    <pre class="language-php"><code>$this
    ->integer(150)
        ->isGreaterThan(100)
        ->isLowerThanOrEqualTo(200);</code></pre>

    <p>The following example asserts that <code>1 - 0.97</code> is nearly equal
        to <code>0.03</code> (which is
        <a href="http://www.floating-point-gui.de/errors/comparison/">strictly
            false in Computer Science</a>):</p>

    <pre class="language-php"><code>$this
    ->float(1 - 0.97)
        ->isNearlyEqualTo(0.03) // passes
        ->isEqualTo(0.03);      // fails</code></pre>

    <p>Arrays, strings, objects, exceptions… all of them have specific
        collections of asserters. In addition to provide a better readability,
        they provide a better <strong>feedback</strong> when a test fails because
        atoum knows what you meant to do.</p>
    <p>A “<strong>diff</strong>” between the expected value and the
        computed value is also produced when a test fails.</p>
</section>

<section class="visual-section">
    <h2>Mocks</h2>

    <p>Mocks able to close dependencies of your system under test. Test
        cases will be faster to build and to execute. atoum provides mocking
        for:</p>
    <ul>
        <li><strong>Classes</strong>, by simply using the top-namespace
            <code>mock</code> (case insensitive); for instance, the following example
            will mock the <code>Foo\Bar</code> class and will provide a new
            implementation for the <code>methodBaz</code> method:</li>
    </ul>
    <pre class="language-php"><code>$mockedObject = new \Mock\Foo\Bar();
$this->calling($mockedObject)->methodBaz = function ($x) {
    return $x * 2;
};</code></pre>

    <ul>
        <li><strong>Functions</strong>, by using the <code>function</code>
            “asserter”; the following example will mock the
            <a href="http://php.net/session_start"><code>session_start</code></a> PHP
            function and will provide a new implementation:</li>
    </ul>
    <pre class="language-php"><code>$this->function->session_start = function () {
    return false;
};</code></pre>

    <ul>
        <li><strong>Constants</strong>, by using the <code>constant</code>
            “asserter”; the following example will mock the
            <a href="http://php.net/phpversion"><code>PHP_VERSION_ID</code></a>
            constant and will provide a new value:</li>
    </ul>
    <pre class="language-php"><code>$this->constant->PHP_VERSION_ID = 606060; // troll spotted</code></pre>

    <p>Mocks are generated at runtime and they are just that easy to use.</p>
    <p>Of course, you can mock class constructor, you can control the value to
        compute each time a method is called, you can assert that a method has
        been called at least once etc.</p>
</section>

<section class="visual-section">
    <h2>Virtual file system</h2>

    <p>When manipulating files or directories, having real files is not
        required. atoum provides a virtual file system allowing to fake real files
        and directories. Enter <code>atoum://</code>. The following example will
        create a virtual file and the resulting resource can be used like any other
        regular file resources:</p>
    <pre class="language-php"><code>$file = atoum\mock\streams\fs\file::get('fakeFile');
fwrite($file, 'foobar');
rewind($file);
// …
stream_get_contents($file); // string(6) "foobar"</code></pre>

    <p>As expected, you can control the permissions, the ownership, different
        times, content, parents etc.</p>
</section>

<section class="visual-section">
    <h2>Reports</h2>

    <p>Either test suites are run by one single user, or by a continous
        integration server. In both cases (but most importantly in the latter),
        having test reports is crucial to understand failures, regressions,
        performances etc. That's why atoum is able to produce several reports
        like:</p>
    <ul>
        <li><a href="http://testanything.org/">TAP</a>, the Test Anything
            Protocol, a language agnostic format,</li>
        <li><a href="https://confluence.atlassian.com/display/CLOVER/Clover+Documentation+Home">clover</a>,
            a software and a format for test reports,</li>
        <li><a href="https://wiki.jenkins-ci.org/display/JENKINS/xUnit+Plugin">xUnit</a>,
            a Jenkins plugin and a format for test reports,</li>
        <li>Your own, yes, this is really easy to plug your own reporter.</li>
    </ul>
    <p>Whatever you are using <a href="https://jenkins-ci.org/">Jenkins</a>,
        <a href="https://travis-ci.org/">Travis</a> or any other well-known
        softwares, they are likely to understand atoum.</p>
</section>

<section class="visual-section">
    <h2>Loop and autorun modes</h2>

    <p>In order to help you as much as possible, atoum provides the <strong>loop
        mode</strong>. Simply using the <code>--loop</code> option on the
        command-line tool will run all the tests and it will wait you to press
        <kbd>Enter</kbd> before restarting the run. If test cases were failling,
        atoum will <strong>only re-run these ones</strong>. You will save time and
        CPU. If no test cases were failling, atoum will re-run all your test
        suites.</p>
    <pre class="language-shell"><code>$ bin/atoum … --loop
…
Press &lt;Enter> to reexecute, press any other key and &lt;Enter> to stop...</code></pre>
    <p>The autorun helps you to run any test cases in any file like a regular
        PHP file if the runner is included. It means you can avoid using the
        command-line tool. Thus, both following examples are equivalent (assuming
        the runner is included):</p>
  <pre class="language-shell"><code>$ bin/atoum --files Test/Unit/Foo.php
$ # is equivalent to…
$ php Test/Unit/Foo.php</code></pre>
</section>

<section class="visual-section">
    <h2>Configuration file in PHP</h2>

    <p>atoum's configuration file is written in PHP. No YAML, no XML, no strange
        language. Only PHP for a maximum flexibility.</p>
    <pre class="language-php"><code>$script->addDefaultArguments(
    '--debug',
    '--use-tap-report',
    '--loop'
);
$runner->addTestsFromDirectory(__DIR__ . '/Test/Unit/');
// …</code></pre>
    <p>Note the global <code>$script</code> and <code>$runner</code> variables:
        Reach any part of atoum to fit in your own workflow.</p>
</section>

<section class="visual-section">
    <h2>Third-party integration</h2>

    <p>atoum integrates well with the following non-exhaustive softwares or
        services:</p>
    <ul class="columns" data-columns="3" style="margin: 0 auto; max-width: 500px">
        <li><a href="https://atom.io/">Atom</a>,</li>
        <li><a href="https://circleci.com/">Circle CI</a>,</li>
        <li><a href="https://getcomposer.org/">Composer</a>,</li>
        <li><a href="http://portablegvim.sourceforge.net/">GVim</a>,</li>
        <li><a href="https://jenkins-ci.org/">Jenkins</a>,</li>
        <li><a href="https://maven.apache.org/">Maven</a>,</li>
        <li><a href="https://www.jetbrains.com/phpstorm/">PHPStorm</a>,</li>
        <li><a href="http://www.phing.info/">Phing</a>,</li>
        <li><a href="https://scrutinizer-ci.com/">Scrutinizer CI</a>,</li>
        <li><a href="http://www.sublimetext.com/">Sublime Text</a>,</li>
        <li><a href="https://travis-ci.org/">Travis CI</a>,</li>
        <li><a href="http://www.vim.org/">Vim</a>,</li>
        <li><a href="https://wiki.gnome.org/Apps/Gedit">gedit</a>,</li>
        <li><a href="https://github.com/macvim-dev/macvim">macvim</a>.</li>
    </ul>
</section>

<section class="visual-section">
    <h2>Fast</h2>

    <p>First, atoum comes with a concurrent engine, which makes it fast (and
        secure) by default. Second, atoum is lightweight. For instance, the
        following table shows the time and memory required to run atoum's test suite
        and <a href="http://hoa-project.net/">Hoa</a>'s test suite, which are known
        to be important and intensive, both in terms of computation and memory:</p>
    <table style="max-width: 500px">
        <caption>This table illustrates how fast atoum is by showing numbers about
            big test suites.</caption>
        <thead>
        <tr>
            <th></th>
            <th>atoum</th>
            <th>Hoa</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>Test suites</td>
            <td>224</td>
            <td>81</td>
        </tr>
        <tr>
            <td>Test cases</td>
            <td>1816</td>
            <td>611</td>
        </tr>
        <tr>
            <td>Assertions</td>
            <td>26,774</td>
            <td>177,976</td>
        </tr>
        <tr class="table--double-separator">
            <td>Time</td>
            <td>25s</td>
            <td>93s</td>
        </tr>
        <tr>
            <td>Memory</td>
            <td>58Mb</td>
            <td>50Mb</td>
        </tr>
        </tbody>
    </table>
    <p>In the case of Hoa's test suite, test data are generated on-the-fly with
        advanced algorithms. atoum's test data are randomly generated
        on-the-fly.</p>
</section>

<section class="visual-section">
    <h2>Extensions</h2>

    <p>atoum is extensible. The community writes extensions and the organization
        of atoum hosts and maintains some of them, like:</p>
    <ul>
        <li><a href="https://github.com/atoum/bdd-extension"><code>atoum/bdd-extension</code></a>,
            to write BDD-like test cases,</li>
        <li><a href="https://github.com/atoum/reports-extension"><code>atoum/reports-extension</code></a>,
            to write code coverage reports (showing branch and path coverage on the
            code or on the control flow graph),</li>
        <li><a href="https://github.com/atoum/ruler-extension"><code>atoum/ruler-extension</code></a>,
            to precisely filter test cases to run with a “natural language”,</li>
        <li><a href="https://github.com/atoum/json-schema-extension"><code>atoum/json-schema-extension</code></a>,
            to validate JSON documents with new asserters,</li>
        <li><a href="https://github.com/atoum/visibility-extension"><code>atoum/visibility-extension</code></a>,
            to bypass the visibility of methods.</li>
    </ul>
    <p>Most of the time, to install an extension you will just need to include
        it in your dependencies and add one line in your configuration file,
        like:</p>
    <pre class="language-php"><code>$runner->addExtension(new mageekguy\atoum\ruler\extension());</code></pre>
</section>
